<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>⚡ Algorithm Visualizer — WCNegentropy</title>
  <meta name="description" content="Interactive algorithm visualizations by WCNegentropy. Watch sorting algorithms, pathfinding, and neural networks come to life.">
  <link rel="canonical" href="https://WCNegentropy.github.io/algorithms">
  <meta name="theme-color" content="#0ea5e9">
  
  <!-- Security Headers -->
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta http-equiv="X-Frame-Options" content="DENY">
  <meta http-equiv="X-XSS-Protection" content="1; mode=block">
  <meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin">
  <meta http-equiv="Permissions-Policy" content="geolocation=(), microphone=(), camera=()">

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: { sans: ['Inter', 'ui-sans-serif', 'system-ui'] },
          colors: {
            brand: {
              50: '#e6f8ff', 100: '#ccefff', 200: '#99dfff', 300: '#66cfff', 400: '#33bfff',
              500: '#0ea5e9', 600: '#0284c7', 700: '#0369a1', 800: '#075985', 900: '#0c4a6e'
            }
          },
          boxShadow: { glow: '0 10px 30px rgba(14,165,233,0.25)' }
        }
      }
    }
  </script>

  <style>
    :root { color-scheme: light dark; }
    body { font-family: Inter, ui-sans-serif, system-ui; }
    .bg-grid {
      background-image: radial-gradient( circle at 1px 1px, rgba(0,0,0,.05) 1px, transparent 0 );
      background-size: 22px 22px;
    }
    .blob {
      position: absolute; filter: blur(70px); opacity: .2; pointer-events:none;
      background: conic-gradient(from 90deg at 50% 50%, #60a5fa, #a78bfa, #22d3ee, #60a5fa);
      /* animation: spin 20s linear infinite; Temporarily disabled */
    }
    @keyframes spin { to { transform: rotate(1turn); } }
    
    /* Algorithm specific styles */
    .array-bar {
      transition: all 0.3s ease;
      border-radius: 4px 4px 0 0;
    }
    .grid-cell {
      border: 1px solid rgba(148, 163, 184, 0.3);
      transition: all 0.2s ease;
    }
    .path { background-color: #22d3ee !important; }
    .wall { background-color: #374151 !important; }
    .start { background-color: #10b981 !important; }
    .end { background-color: #ef4444 !important; }
    .visited { background-color: #a78bfa !important; }
    
    /* Neural network styles */
    .neuron { transition: all 0.3s ease; }
    .connection { transition: all 0.3s ease; }
    
    /* Canvas styling */
    canvas {
      background: #ffffff;
      border: 1px solid rgba(148, 163, 184, 0.3);
    }
    .dark canvas {
      background: #1e293b;
      border-color: rgba(148, 163, 184, 0.2);
    }
  </style>
</head>

<body class="bg-white text-slate-800 dark:bg-slate-950 dark:text-slate-100">
  <!-- Background blobs -->
  <div class="blob w-[30vw] h-[30vw] top-[-10vw] left-[-10vw] rounded-full"></div>
  <div class="blob w-[25vw] h-[25vw] bottom-[-10vw] right-[-10vw] rounded-full"></div>

  <!-- HEADER -->
  <header class="sticky top-0 z-40 backdrop-blur supports-[backdrop-filter]:bg-white/70 dark:supports-[backdrop-filter]:bg-slate-900/60 border-b border-slate-200/60 dark:border-slate-800">
    <div class="mx-auto max-w-7xl px-6 py-4 flex items-center justify-between">
      <a href="/" class="flex items-center gap-3 group">
        <img src="https://github.com/WCNegentropy.png" class="size-10 rounded-full ring-2 ring-brand-400/40" alt="WCNegentropy" />
        <div>
          <div class="font-semibold tracking-tight group-hover:text-brand-600 transition">WCNegentropy</div>
          <div class="text-xs text-slate-500 dark:text-slate-400">Algorithm Visualizer</div>
        </div>
      </a>
      <nav class="hidden md:flex items-center gap-6 text-sm">
        <a href="/" class="hover:text-brand-600">Home</a>
        <a href="#sorting" class="hover:text-brand-600">Sorting</a>
        <a href="#pathfinding" class="hover:text-brand-600">Pathfinding</a>
        <a href="#neural" class="hover:text-brand-600">Neural Networks</a>
        <a href="/playground.html" class="hover:text-brand-600">Code Playground</a>
      </nav>
      <div class="flex items-center gap-2">
        <button id="theme-toggle" class="inline-flex items-center gap-2 rounded-xl border border-slate-200 dark:border-slate-700 px-3 py-1.5 text-xs hover:shadow-glow transition">
          <span class="i-theme">🌞</span><span class="hidden sm:inline">Theme</span>
        </button>
      </div>
    </div>
  </header>

  <!-- HERO -->
  <section class="relative overflow-hidden">
    <div class="absolute inset-0 bg-grid pointer-events-none"></div>
    <div class="mx-auto max-w-7xl px-6 pt-16 pb-12">
      <div class="text-center">
        <h1 class="text-4xl sm:text-5xl font-extrabold tracking-tight">
          Algorithm <span class="text-transparent bg-clip-text bg-gradient-to-r from-brand-500 to-violet-500">Visualizer</span>
        </h1>
        <p class="mt-4 text-lg text-slate-600 dark:text-slate-300 max-w-2xl mx-auto">
          Watch algorithms come to life. Interactive visualizations of sorting, pathfinding, and neural networks.
        </p>
      </div>
    </div>
  </section>

  <!-- SORTING ALGORITHMS -->
  <section id="sorting" class="mx-auto max-w-7xl px-6 py-16">
    <h2 class="text-3xl font-extrabold tracking-tight mb-8">Sorting Algorithms</h2>
    
    <div class="bg-slate-50 dark:bg-slate-900 rounded-2xl p-6 mb-8">
      <div class="flex flex-wrap items-center gap-4 mb-6">
        <select id="sortAlgorithm" class="rounded-xl border border-slate-300 dark:border-slate-600 bg-transparent px-4 py-2">
          <option value="bubble">Bubble Sort</option>
          <option value="quick">Quick Sort</option>
          <option value="merge">Merge Sort</option>
          <option value="heap">Heap Sort</option>
        </select>
        <button id="sortStart" class="rounded-xl bg-brand-600 text-white px-4 py-2 font-semibold hover:bg-brand-700">Start</button>
        <button id="sortReset" class="rounded-xl border border-slate-300 dark:border-slate-600 px-4 py-2 font-semibold">Reset</button>
        <div class="text-sm text-slate-600 dark:text-slate-400">
          Speed: <input type="range" id="sortSpeed" min="1" max="100" value="50" class="ml-2">
        </div>
      </div>
      <div id="sortVisualization" class="h-64 flex items-end justify-center gap-1 bg-white dark:bg-slate-800 rounded-xl p-4"></div>
      <div id="sortStats" class="mt-4 text-sm text-slate-600 dark:text-slate-400 text-center"></div>
    </div>
  </section>

  <!-- PATHFINDING -->
  <section id="pathfinding" class="mx-auto max-w-7xl px-6 py-16">
    <h2 class="text-3xl font-extrabold tracking-tight mb-8">Pathfinding Algorithms</h2>
    
    <div class="bg-slate-50 dark:bg-slate-900 rounded-2xl p-6 mb-8">
      <div class="flex flex-wrap items-center gap-4 mb-6">
        <select id="pathAlgorithm" class="rounded-xl border border-slate-300 dark:border-slate-600 bg-transparent px-4 py-2">
          <option value="astar">A* Search</option>
          <option value="dijkstra">Dijkstra's</option>
          <option value="bfs">Breadth-First Search</option>
          <option value="dfs">Depth-First Search</option>
        </select>
        <button id="pathStart" class="rounded-xl bg-brand-600 text-white px-4 py-2 font-semibold hover:bg-brand-700">Find Path</button>
        <button id="pathReset" class="rounded-xl border border-slate-300 dark:border-slate-600 px-4 py-2 font-semibold">Reset</button>
        <div class="text-sm text-slate-600 dark:text-slate-400">
          Click to add walls | Drag start/end points
        </div>
      </div>
      <div id="pathGrid" class="grid gap-0 w-full max-w-4xl mx-auto bg-white dark:bg-slate-800 rounded-xl p-4" style="grid-template-columns: repeat(20, 1fr);"></div>
      <div id="pathStats" class="mt-4 text-sm text-slate-600 dark:text-slate-400 text-center"></div>
    </div>
  </section>

  <!-- NEURAL NETWORK -->
  <section id="neural" class="mx-auto max-w-7xl px-6 py-16">
    <h2 class="text-3xl font-extrabold tracking-tight mb-8">Neural Network Visualization</h2>
    
    <div class="bg-slate-50 dark:bg-slate-900 rounded-2xl p-6 mb-8">
      <div class="flex flex-wrap items-center gap-4 mb-6">
        <select id="neuralExample" class="rounded-xl border border-slate-300 dark:border-slate-600 bg-transparent px-4 py-2">
          <option value="xor">XOR Gate</option>
          <option value="classification">Binary Classification</option>
          <option value="regression">Simple Regression</option>
        </select>
        <button id="neuralTrain" class="rounded-xl bg-brand-600 text-white px-4 py-2 font-semibold hover:bg-brand-700">Train Network</button>
        <button id="neuralReset" class="rounded-xl border border-slate-300 dark:border-slate-600 px-4 py-2 font-semibold">Reset</button>
        <div class="text-sm text-slate-600 dark:text-slate-400">
          Learning Rate: <input type="range" id="learningRate" min="0.01" max="1" step="0.01" value="0.1" class="ml-2">
        </div>
      </div>
      <div class="grid md:grid-cols-2 gap-6">
        <div>
          <canvas id="neuralNetwork" width="400" height="300" class="w-full bg-white dark:bg-slate-800 rounded-xl"></canvas>
        </div>
        <div>
          <canvas id="lossChart" width="400" height="300" class="w-full bg-white dark:bg-slate-800 rounded-xl"></canvas>
        </div>
      </div>
      <div id="neuralStats" class="mt-4 text-sm text-slate-600 dark:text-slate-400 text-center"></div>
    </div>
  </section>

  <!-- FOOTER -->
  <footer class="border-t border-slate-200 dark:border-slate-800 py-10">
    <div class="mx-auto max-w-7xl px-6 text-center">
      <p class="text-sm text-slate-500">© 2024 WCNegentropy. Interactive algorithm demonstrations.</p>
      <div class="mt-4">
        <a href="/" class="text-brand-600 hover:underline">← Back to Home</a>
      </div>
    </div>
  </footer>

  <!-- SCRIPTS -->
  <script>
    console.log('🚀 Algorithm Visualizer script starting...');
    // Theme system
    const applyTheme = (t) => {
      const root = document.documentElement;
      if (t === 'dark') root.classList.add('dark'); else root.classList.remove('dark');
      document.querySelector('.i-theme').textContent = t === 'dark' ? '🌙' : '🌞';
      localStorage.setItem('theme', t);
    }
    const initTheme = () => {
      const pref = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
      applyTheme(pref);
    }

    // Sorting Algorithm Implementation
    class SortingVisualizer {
      constructor() {
        this.array = [];
        this.isRunning = false;
        this.size = 50;
        this.speed = 50;
        this.comparisons = 0;
        this.swaps = 0;
        this.initArray();
      }

      initArray() {
        this.array = Array.from({length: this.size}, () => Math.floor(Math.random() * 250) + 10);
        this.render();
      }

      render() {
        const container = document.getElementById('sortVisualization');
        if (!container) return;
        
        container.innerHTML = '';
        
        // Use fixed width to prevent layout thrashing
        const barWidth = Math.max(8, Math.min(20, 800 / this.size));
        
        this.array.forEach((value, index) => {
          const bar = document.createElement('div');
          bar.className = 'array-bar bg-brand-500';
          bar.style.height = `${value}px`;
          bar.style.width = `${barWidth}px`;
          bar.style.marginRight = '2px';
          bar.dataset.index = index;
          container.appendChild(bar);
        });
      }

      async delay() {
        return new Promise(resolve => setTimeout(resolve, 101 - this.speed));
      }

      async highlightBars(indices, color = '#ef4444') {
        indices.forEach(i => {
          if (i < this.array.length) {
            const bar = document.querySelector(`[data-index="${i}"]`);
            if (bar) bar.style.backgroundColor = color;
          }
        });
        await this.delay();
      }

      resetBarColors() {
        document.querySelectorAll('.array-bar').forEach(bar => {
          bar.style.backgroundColor = '#0ea5e9';
        });
      }

      async swap(i, j) {
        this.swaps++;
        [this.array[i], this.array[j]] = [this.array[j], this.array[i]];
        this.render();
        await this.highlightBars([i, j], '#22d3ee');
        this.updateStats();
      }

      async bubbleSort() {
        const n = this.array.length;
        for (let i = 0; i < n - 1; i++) {
          for (let j = 0; j < n - i - 1; j++) {
            if (!this.isRunning) return;
            this.comparisons++;
            await this.highlightBars([j, j + 1], '#fbbf24');
            if (this.array[j] > this.array[j + 1]) {
              await this.swap(j, j + 1);
            }
            this.resetBarColors();
          }
        }
      }

      async quickSort(arr = this.array, start = 0, end = this.array.length - 1) {
        if (start < end) {
          const pi = await this.partition(arr, start, end);
          await this.quickSort(arr, start, pi - 1);
          await this.quickSort(arr, pi + 1, end);
        }
      }

      async partition(arr, start, end) {
        const pivot = arr[end];
        let i = start - 1;

        for (let j = start; j < end; j++) {
          if (!this.isRunning) return;
          this.comparisons++;
          await this.highlightBars([j, end], '#fbbf24');
          if (arr[j] < pivot) {
            i++;
            if (i !== j) await this.swap(i, j);
          }
          this.resetBarColors();
        }
        if (i + 1 !== end) await this.swap(i + 1, end);
        return i + 1;
      }

      async mergeSort(arr = [...this.array], start = 0, end = this.array.length - 1) {
        if (start >= end) return arr;
        
        const mid = Math.floor((start + end) / 2);
        const left = await this.mergeSort(arr, start, mid);
        const right = await this.mergeSort(arr, mid + 1, end);
        return await this.merge(left, right, start, end);
      }

      async merge(left, right, start, end) {
        const result = [];
        let i = 0, j = 0;

        while (i < left.length && j < right.length) {
          if (!this.isRunning) return result.concat(left.slice(i)).concat(right.slice(j));
          this.comparisons++;
          
          if (left[i] <= right[j]) {
            result.push(left[i]);
            i++;
          } else {
            result.push(right[j]);
            j++;
          }
          
          // Update the main array for visualization
          for (let k = 0; k < result.length; k++) {
            this.array[start + k] = result[k];
          }
          this.render();
          await this.highlightBars([start + result.length - 1], '#22d3ee');
          this.resetBarColors();
        }

        while (i < left.length) {
          result.push(left[i]);
          this.array[start + result.length - 1] = left[i];
          i++;
        }

        while (j < right.length) {
          result.push(right[j]);
          this.array[start + result.length - 1] = right[j];
          j++;
        }

        return result;
      }

      async heapSort() {
        const n = this.array.length;
        
        // Build heap
        for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
          await this.heapify(n, i);
        }
        
        // Extract elements from heap
        for (let i = n - 1; i > 0; i--) {
          await this.swap(0, i);
          await this.heapify(i, 0);
        }
      }

      async heapify(n, i) {
        let largest = i;
        const left = 2 * i + 1;
        const right = 2 * i + 2;

        if (left < n) {
          this.comparisons++;
          await this.highlightBars([left, largest], '#fbbf24');
          if (this.array[left] > this.array[largest]) {
            largest = left;
          }
        }

        if (right < n) {
          this.comparisons++;
          await this.highlightBars([right, largest], '#fbbf24');
          if (this.array[right] > this.array[largest]) {
            largest = right;
          }
        }

        if (largest !== i) {
          await this.swap(i, largest);
          await this.heapify(n, largest);
        }
        this.resetBarColors();
      }

      updateStats() {
        document.getElementById('sortStats').textContent = 
          `Comparisons: ${this.comparisons} | Swaps: ${this.swaps}`;
      }

      async start() {
        if (this.isRunning) return;
        this.isRunning = true;
        this.comparisons = 0;
        this.swaps = 0;
        
        const algorithm = document.getElementById('sortAlgorithm').value;
        
        switch (algorithm) {
          case 'bubble':
            await this.bubbleSort();
            break;
          case 'quick':
            await this.quickSort();
            break;
          case 'merge':
            await this.mergeSort();
            break;
          case 'heap':
            await this.heapSort();
            break;
        }
        
        this.isRunning = false;
      }

      reset() {
        this.isRunning = false;
        this.comparisons = 0;
        this.swaps = 0;
        this.initArray();
        this.updateStats();
      }
    }

    // Pathfinding Implementation
    class PathfindingVisualizer {
      constructor() {
        this.rows = 15;
        this.cols = 20;
        this.grid = [];
        this.start = {row: 5, col: 2};
        this.end = {row: 8, col: 17};
        this.isRunning = false;
        this.initGrid();
      }

      initGrid() {
        this.grid = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
        this.render();
      }

      render() {
        const container = document.getElementById('pathGrid');
        if (!container) return;
        
        container.innerHTML = '';
        container.style.gridTemplateRows = `repeat(${this.rows}, minmax(20px, 1fr))`;
        container.style.gridTemplateColumns = `repeat(${this.cols}, minmax(20px, 1fr))`;
        container.style.aspectRatio = `${this.cols}/${this.rows}`;
        
        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.cols; col++) {
            const cell = document.createElement('div');
            cell.className = 'grid-cell bg-white dark:bg-slate-700 cursor-pointer transition-colors duration-200';
            cell.style.minHeight = '20px';
            cell.style.minWidth = '20px';
            cell.dataset.row = row;
            cell.dataset.col = col;
            
            if (row === this.start.row && col === this.start.col) {
              cell.classList.add('start');
            } else if (row === this.end.row && col === this.end.col) {
              cell.classList.add('end');
            } else if (this.grid[row][col] === 1) {
              cell.classList.add('wall');
            }
            
            cell.addEventListener('click', () => this.toggleWall(row, col));
            container.appendChild(cell);
          }
        }
      }

      toggleWall(row, col) {
        if (this.isRunning) return; // Prevent changes during algorithm execution
        if ((row === this.start.row && col === this.start.col) || 
            (row === this.end.row && col === this.end.col)) return;
        
        this.grid[row][col] = this.grid[row][col] === 1 ? 0 : 1;
        
        // Update only the specific cell instead of full re-render
        const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
        if (cell) {
          if (this.grid[row][col] === 1) {
            cell.classList.add('wall');
            cell.classList.remove('visited', 'path');
          } else {
            cell.classList.remove('wall', 'visited', 'path');
          }
        }
      }

      async aStar() {
        // Simplified A* implementation for demo
        const openSet = [{...this.start, f: 0, g: 0, h: 0, parent: null}];
        const closedSet = new Set();
        const visited = new Set();
        let iterations = 0;
        const maxIterations = this.rows * this.cols * 2; // Safety limit

        while (openSet.length > 0 && this.isRunning && iterations < maxIterations) {
          iterations++;
          openSet.sort((a, b) => a.f - b.f);
          const current = openSet.shift();
          
          if (current.row === this.end.row && current.col === this.end.col) {
            // Reconstruct path
            let path = [];
            let node = current;
            while (node) {
              path.unshift(node);
              node = node.parent;
            }
            await this.animatePath(path);
            return;
          }

          closedSet.add(`${current.row},${current.col}`);
          
          // Visualize visited node
          if (current.row !== this.start.row || current.col !== this.start.col) {
            const cell = document.querySelector(`[data-row="${current.row}"][data-col="${current.col}"]`);
            if (cell) cell.classList.add('visited');
          }
          
          await new Promise(resolve => setTimeout(resolve, 50));

          // Check neighbors
          const neighbors = [
            {row: current.row - 1, col: current.col},
            {row: current.row + 1, col: current.col},
            {row: current.row, col: current.col - 1},
            {row: current.row, col: current.col + 1}
          ];

          for (let neighbor of neighbors) {
            if (neighbor.row < 0 || neighbor.row >= this.rows || 
                neighbor.col < 0 || neighbor.col >= this.cols ||
                this.grid[neighbor.row][neighbor.col] === 1 ||
                closedSet.has(`${neighbor.row},${neighbor.col}`)) continue;

            const g = current.g + 1;
            const h = Math.abs(neighbor.row - this.end.row) + Math.abs(neighbor.col - this.end.col);
            const f = g + h;

            const existing = openSet.find(node => node.row === neighbor.row && node.col === neighbor.col);
            if (!existing) {
              openSet.push({...neighbor, f, g, h, parent: current});
            } else if (g < existing.g) {
              existing.g = g;
              existing.f = f;
              existing.parent = current;
            }
          }
        }
      }

      async dijkstra() {
        const distances = Array(this.rows).fill().map(() => Array(this.cols).fill(Infinity));
        const previous = Array(this.rows).fill().map(() => Array(this.cols).fill(null));
        const unvisited = new Set();
        
        // Initialize
        distances[this.start.row][this.start.col] = 0;
        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.cols; col++) {
            if (this.grid[row][col] !== 1) {
              unvisited.add(`${row},${col}`);
            }
          }
        }

        while (unvisited.size > 0 && this.isRunning) {
          // Find node with minimum distance
          let current = null;
          let minDist = Infinity;
          
          for (let nodeKey of unvisited) {
            const [row, col] = nodeKey.split(',').map(Number);
            if (distances[row][col] < minDist) {
              minDist = distances[row][col];
              current = {row, col};
            }
          }
          
          if (!current || minDist === Infinity) break;
          
          unvisited.delete(`${current.row},${current.col}`);
          
          // Visualize
          if (current.row !== this.start.row || current.col !== this.start.col) {
            const cell = document.querySelector(`[data-row="${current.row}"][data-col="${current.col}"]`);
            if (cell) cell.classList.add('visited');
          }
          
          if (current.row === this.end.row && current.col === this.end.col) {
            await this.reconstructPath(previous, current);
            return;
          }
          
          await new Promise(resolve => setTimeout(resolve, 50));

          // Check neighbors
          const neighbors = [
            {row: current.row - 1, col: current.col},
            {row: current.row + 1, col: current.col},
            {row: current.row, col: current.col - 1},
            {row: current.row, col: current.col + 1}
          ];

          for (let neighbor of neighbors) {
            if (neighbor.row >= 0 && neighbor.row < this.rows && 
                neighbor.col >= 0 && neighbor.col < this.cols &&
                this.grid[neighbor.row][neighbor.col] !== 1 &&
                unvisited.has(`${neighbor.row},${neighbor.col}`)) {
              
              const newDist = distances[current.row][current.col] + 1;
              if (newDist < distances[neighbor.row][neighbor.col]) {
                distances[neighbor.row][neighbor.col] = newDist;
                previous[neighbor.row][neighbor.col] = current;
              }
            }
          }
        }
      }

      async bfs() {
        const queue = [{...this.start, parent: null}];
        const visited = new Set([`${this.start.row},${this.start.col}`]);

        while (queue.length > 0 && this.isRunning) {
          const current = queue.shift();
          
          if (current.row === this.end.row && current.col === this.end.col) {
            const path = [];
            let node = current;
            while (node) {
              path.unshift(node);
              node = node.parent;
            }
            await this.animatePath(path);
            return;
          }

          // Visualize
          if (current.row !== this.start.row || current.col !== this.start.col) {
            const cell = document.querySelector(`[data-row="${current.row}"][data-col="${current.col}"]`);
            if (cell) cell.classList.add('visited');
          }
          
          await new Promise(resolve => setTimeout(resolve, 50));

          const neighbors = [
            {row: current.row - 1, col: current.col},
            {row: current.row + 1, col: current.col},
            {row: current.row, col: current.col - 1},
            {row: current.row, col: current.col + 1}
          ];

          for (let neighbor of neighbors) {
            const key = `${neighbor.row},${neighbor.col}`;
            if (neighbor.row >= 0 && neighbor.row < this.rows && 
                neighbor.col >= 0 && neighbor.col < this.cols &&
                this.grid[neighbor.row][neighbor.col] !== 1 &&
                !visited.has(key)) {
              
              visited.add(key);
              queue.push({...neighbor, parent: current});
            }
          }
        }
      }

      async dfs() {
        const stack = [{...this.start, parent: null}];
        const visited = new Set();

        while (stack.length > 0 && this.isRunning) {
          const current = stack.pop();
          const key = `${current.row},${current.col}`;
          
          if (visited.has(key)) continue;
          visited.add(key);
          
          if (current.row === this.end.row && current.col === this.end.col) {
            const path = [];
            let node = current;
            while (node) {
              path.unshift(node);
              node = node.parent;
            }
            await this.animatePath(path);
            return;
          }

          // Visualize
          if (current.row !== this.start.row || current.col !== this.start.col) {
            const cell = document.querySelector(`[data-row="${current.row}"][data-col="${current.col}"]`);
            if (cell) cell.classList.add('visited');
          }
          
          await new Promise(resolve => setTimeout(resolve, 50));

          const neighbors = [
            {row: current.row - 1, col: current.col},
            {row: current.row + 1, col: current.col},
            {row: current.row, col: current.col - 1},
            {row: current.row, col: current.col + 1}
          ];

          for (let neighbor of neighbors) {
            const key = `${neighbor.row},${neighbor.col}`;
            if (neighbor.row >= 0 && neighbor.row < this.rows && 
                neighbor.col >= 0 && neighbor.col < this.cols &&
                this.grid[neighbor.row][neighbor.col] !== 1 &&
                !visited.has(key)) {
              
              stack.push({...neighbor, parent: current});
            }
          }
        }
      }

      async reconstructPath(previous, end) {
        const path = [];
        let current = end;
        
        while (current) {
          path.unshift(current);
          current = previous[current.row][current.col];
        }
        
        await this.animatePath(path);
      }

      async animatePath(path) {
        for (let node of path) {
          if (node.row !== this.start.row || node.col !== this.start.col) {
            if (node.row !== this.end.row || node.col !== this.end.col) {
              const cell = document.querySelector(`[data-row="${node.row}"][data-col="${node.col}"]`);
              if (cell) cell.classList.add('path');
            }
          }
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }

      async start() {
        if (this.isRunning) return;
        this.isRunning = true;
        
        // Clear previous visualization
        document.querySelectorAll('.visited, .path').forEach(cell => {
          cell.classList.remove('visited', 'path');
        });

        // Update stats display
        const statsElement = document.getElementById('pathStats');
        if (statsElement) {
          statsElement.textContent = 'Running pathfinding algorithm...';
        }

        const algorithm = document.getElementById('pathAlgorithm').value;
        console.log(`Starting ${algorithm} pathfinding algorithm`);
        
        try {
          switch (algorithm) {
            case 'astar':
              await this.aStar();
              break;
            case 'dijkstra':
              await this.dijkstra();
              break;
            case 'bfs':
              await this.bfs();
              break;
            case 'dfs':
              await this.dfs();
              break;
            default:
              console.error('Unknown algorithm:', algorithm);
          }
          
          if (statsElement) {
            statsElement.textContent = `${algorithm.toUpperCase()} algorithm completed!`;
          }
        } catch (error) {
          console.error('Pathfinding error:', error);
          if (statsElement) {
            statsElement.textContent = 'Algorithm encountered an error.';
          }
        }
        
        this.isRunning = false;
      }

      reset() {
        this.isRunning = false;
        this.initGrid();
      }
    }

    // Neural Network Visualization
    class NeuralNetworkVisualizer {
      constructor() {
        this.canvas = document.getElementById('neuralNetwork');
        this.lossCanvas = document.getElementById('lossChart');
        
        if (!this.canvas || !this.lossCanvas) {
          console.error('Neural network canvas elements not found');
          return;
        }
        
        this.ctx = this.canvas.getContext('2d');
        this.lossCtx = this.lossCanvas.getContext('2d');
        this.network = null;
        this.lossHistory = [];
        this.isTraining = false;
        
        // Set canvas size
        this.resizeCanvases();
      }
      
      resizeCanvases() {
        // Set fixed dimensions to avoid layout issues
        this.canvas.width = 400;
        this.canvas.height = 300;
        this.lossCanvas.width = 400;
        this.lossCanvas.height = 300;
        
        // Apply CSS sizing for responsiveness
        this.canvas.style.width = '100%';
        this.canvas.style.height = 'auto';
        this.lossCanvas.style.width = '100%';
        this.lossCanvas.style.height = 'auto';
        
        console.log('Neural network canvases resized:', this.canvas.width, 'x', this.canvas.height);
      }

      initNetwork(inputSize = 2, hiddenSize = 4, outputSize = 1) {
        this.network = {
          weights1: this.randomMatrix(inputSize, hiddenSize),
          weights2: this.randomMatrix(hiddenSize, outputSize),
          bias1: this.randomMatrix(1, hiddenSize),
          bias2: this.randomMatrix(1, outputSize)
        };
        this.lossHistory = [];
      }

      randomMatrix(rows, cols) {
        return Array(rows).fill().map(() => Array(cols).fill().map(() => Math.random() * 2 - 1));
      }

      sigmoid(x) {
        return 1 / (1 + Math.exp(-x));
      }

      forward(input) {
        if (!this.network) return { hidden: [], output: [0] };
        
        // Forward pass: input -> hidden
        const hidden = [];
        for (let j = 0; j < this.network.weights1[0].length; j++) {
          let sum = this.network.bias1[0][j];
          for (let i = 0; i < input.length; i++) {
            sum += input[i] * this.network.weights1[i][j];
          }
          hidden.push(this.sigmoid(sum));
        }
        
        // Forward pass: hidden -> output
        const output = [];
        for (let k = 0; k < this.network.weights2[0].length; k++) {
          let sum = this.network.bias2[0][k];
          for (let j = 0; j < hidden.length; j++) {
            sum += hidden[j] * this.network.weights2[j][k];
          }
          output.push(this.sigmoid(sum));
        }
        
        return { hidden, output };
      }

      drawNetwork() {
        if (!this.ctx) {
          console.error('Canvas context not available');
          return;
        }
        
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Network structure
        const layers = [2, 4, 1]; // input, hidden, output
        const layerX = [60, 200, 340];
        const nodeRadius = 12;
        const colors = ['#10b981', '#0ea5e9', '#ef4444']; // input, hidden, output
        
        // Draw connections with weights visualization
        this.ctx.lineWidth = 1;
        
        for (let l = 0; l < layers.length - 1; l++) {
          for (let i = 0; i < layers[l]; i++) {
            for (let j = 0; j < layers[l + 1]; j++) {
              const y1 = this.getNodeY(i, layers[l]);
              const y2 = this.getNodeY(j, layers[l + 1]);
              
              // Weight-based connection opacity
              let opacity = 0.5;
              if (this.network && l === 0 && this.network.weights1[i] && this.network.weights1[i][j]) {
                opacity = Math.min(1, Math.abs(this.network.weights1[i][j]) + 0.2);
              } else if (this.network && l === 1 && this.network.weights2[i] && this.network.weights2[i][j]) {
                opacity = Math.min(1, Math.abs(this.network.weights2[i][j]) + 0.2);
              }
              
              this.ctx.strokeStyle = `rgba(100, 116, 139, ${opacity})`;
              this.ctx.beginPath();
              this.ctx.moveTo(layerX[l] + nodeRadius, y1);
              this.ctx.lineTo(layerX[l + 1] - nodeRadius, y2);
              this.ctx.stroke();
            }
          }
        }
        
        // Draw nodes with labels
        layers.forEach((count, l) => {
          for (let i = 0; i < count; i++) {
            const y = this.getNodeY(i, count);
            const x = layerX[l];
            
            // Node circle
            this.ctx.fillStyle = colors[l];
            this.ctx.beginPath();
            this.ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);
            this.ctx.fill();
            
            // Node border
            this.ctx.strokeStyle = '#ffffff';
            this.ctx.lineWidth = 2;
            this.ctx.stroke();
            
            // Node labels
            this.ctx.fillStyle = '#374151';
            this.ctx.font = '10px Inter';
            this.ctx.textAlign = 'center';
            const labels = [['X1', 'X2'], ['H1', 'H2', 'H3', 'H4'], ['Y']];
            if (labels[l] && labels[l][i]) {
              this.ctx.fillText(labels[l][i], x, y + 3);
            }
          }
        });
        
        // Layer labels
        this.ctx.fillStyle = '#6b7280';
        this.ctx.font = '12px Inter';
        this.ctx.textAlign = 'center';
        this.ctx.fillText('Input', layerX[0], 30);
        this.ctx.fillText('Hidden', layerX[1], 30);
        this.ctx.fillText('Output', layerX[2], 30);
      }
      
      getNodeY(nodeIndex, totalNodes) {
        const startY = 80;
        const spacing = Math.min(60, (this.canvas.height - 160) / Math.max(1, totalNodes - 1));
        if (totalNodes === 1) {
          return this.canvas.height / 2;
        }
        return startY + nodeIndex * spacing;
      }

      drawLoss() {
        if (!this.lossCtx) {
          console.error('Loss canvas context not available');
          return;
        }
        
        this.lossCtx.clearRect(0, 0, this.lossCanvas.width, this.lossCanvas.height);
        
        if (this.lossHistory.length < 2) {
          // Draw placeholder text
          this.lossCtx.fillStyle = '#9ca3af';
          this.lossCtx.font = '14px Inter';
          this.lossCtx.textAlign = 'center';
          this.lossCtx.fillText('Loss curve will appear here', this.lossCanvas.width / 2, this.lossCanvas.height / 2);
          return;
        }
        
        // Draw grid lines
        this.lossCtx.strokeStyle = '#e5e7eb';
        this.lossCtx.lineWidth = 1;
        for (let i = 0; i <= 4; i++) {
          const y = (i / 4) * this.lossCanvas.height;
          this.lossCtx.beginPath();
          this.lossCtx.moveTo(40, y);
          this.lossCtx.lineTo(this.lossCanvas.width - 20, y);
          this.lossCtx.stroke();
        }
        
        // Calculate display bounds with padding
        const padding = 40;
        const chartWidth = this.lossCanvas.width - padding - 20;
        const chartHeight = this.lossCanvas.height - 60;
        
        const maxLoss = Math.max(...this.lossHistory);
        const minLoss = Math.min(...this.lossHistory);
        const range = Math.max(maxLoss - minLoss, 0.001); // Prevent division by zero
        
        // Draw loss curve
        this.lossCtx.strokeStyle = '#0ea5e9';
        this.lossCtx.lineWidth = 3;
        this.lossCtx.beginPath();
        
        this.lossHistory.forEach((loss, i) => {
          const x = padding + (i / (this.lossHistory.length - 1)) * chartWidth;
          const normalizedLoss = (loss - minLoss) / range;
          const y = chartHeight - (normalizedLoss * (chartHeight - 40)) + 40;
          
          if (i === 0) this.lossCtx.moveTo(x, y);
          else this.lossCtx.lineTo(x, y);
        });
        
        this.lossCtx.stroke();
        
        // Draw labels
        this.lossCtx.fillStyle = '#374151';
        this.lossCtx.font = '12px Inter';
        this.lossCtx.textAlign = 'center';
        this.lossCtx.fillText('Training Loss Over Time', this.lossCanvas.width / 2, 20);
        
        // Y-axis labels
        this.lossCtx.textAlign = 'right';
        this.lossCtx.fillText(maxLoss.toFixed(3), 35, 45);
        this.lossCtx.fillText(minLoss.toFixed(3), 35, chartHeight + 35);
        
        // X-axis labels  
        this.lossCtx.textAlign = 'center';
        this.lossCtx.fillText('0', padding, this.lossCanvas.height - 10);
        this.lossCtx.fillText(this.lossHistory.length.toString(), this.lossCanvas.width - 20, this.lossCanvas.height - 10);
      }

      async train() {
        if (this.isTraining) return;
        this.isTraining = true;
        
        console.log('Starting neural network training...');
        this.initNetwork();
        this.drawNetwork();
        
        const statsElement = document.getElementById('neuralStats');
        if (statsElement) {
          statsElement.textContent = 'Initializing training...';
        }
        
        // XOR training data
        const data = [
          {input: [0, 0], output: [0]},
          {input: [0, 1], output: [1]},
          {input: [1, 0], output: [1]},
          {input: [1, 1], output: [0]}
        ];
        
        const maxEpochs = 1000;
        const updateInterval = 20;
        
        for (let epoch = 0; epoch < maxEpochs && this.isTraining; epoch++) {
          let totalLoss = 0;
          
          // Calculate loss for all training samples
          for (let sample of data) {
            const result = this.forward(sample.input);
            const loss = Math.pow(result.output[0] - sample.output[0], 2);
            totalLoss += loss;
            
            // Simple gradient descent simulation (weight updates)
            if (this.network) {
              const learningRate = 0.01;
              const error = sample.output[0] - result.output[0];
              
              // Simulate basic weight updates
              for (let i = 0; i < this.network.weights2.length; i++) {
                for (let j = 0; j < this.network.weights2[i].length; j++) {
                  this.network.weights2[i][j] += learningRate * error * result.hidden[i] * 0.1;
                }
              }
            }
          }
          
          const avgLoss = totalLoss / data.length;
          this.lossHistory.push(avgLoss);
          
          // Update visualization periodically
          if (epoch % updateInterval === 0 || epoch === maxEpochs - 1) {
            this.drawNetwork();
            this.drawLoss();
            
            if (statsElement) {
              const progress = ((epoch / maxEpochs) * 100).toFixed(1);
              statsElement.textContent = `Epoch: ${epoch}/${maxEpochs} (${progress}%) | Loss: ${avgLoss.toFixed(6)}`;
            }
            
            // Allow UI updates
            await new Promise(resolve => setTimeout(resolve, 1));
          }
          
          // Early stopping if loss is very low
          if (avgLoss < 0.001) {
            console.log(`Training converged at epoch ${epoch}`);
            break;
          }
        }
        
        if (statsElement) {
          const finalLoss = this.lossHistory[this.lossHistory.length - 1];
          statsElement.textContent = `Training completed! Final loss: ${finalLoss.toFixed(6)}`;
        }
        
        console.log('Neural network training completed');
        this.isTraining = false;
      }
    }

    // Initialize everything when page loads
    document.addEventListener('DOMContentLoaded', () => {
      initTheme();
      
      // Theme toggle
      document.getElementById('theme-toggle').addEventListener('click', () => {
        const t = document.documentElement.classList.contains('dark') ? 'light' : 'dark';
        applyTheme(t);
      });

      // Initialize visualizers
      console.log('Initializing visualizers...');
      const sortViz = new SortingVisualizer();
      console.log('SortingVisualizer created:', !!sortViz);
      const pathViz = new PathfindingVisualizer();
      console.log('PathfindingVisualizer created:', !!pathViz);
      const neuralViz = new NeuralNetworkVisualizer();
      console.log('NeuralNetworkVisualizer created:', !!neuralViz);
      
      // Event listeners with safety checks
      const sortStartBtn = document.getElementById('sortStart');
      const sortResetBtn = document.getElementById('sortReset');
      const sortSpeedSlider = document.getElementById('sortSpeed');
      
      if (sortStartBtn) {
        console.log('Sort start button found');
        sortStartBtn.addEventListener('click', () => {
          console.log('Sort start button clicked');
          if (sortViz) sortViz.start();
        });
      } else {
        console.error('Sort start button not found');
      }
      
      if (sortResetBtn) {
        sortResetBtn.addEventListener('click', () => {
          console.log('Sort reset button clicked');
          if (sortViz) sortViz.reset();
        });
      }
      if (sortSpeedSlider) {
        sortSpeedSlider.addEventListener('input', (e) => {
          if (sortViz) sortViz.speed = parseInt(e.target.value);
        });
      }
      
      const pathStartBtn = document.getElementById('pathStart');
      const pathResetBtn = document.getElementById('pathReset');
      
      if (pathStartBtn) {
        console.log('Pathfinding start button found');
        pathStartBtn.addEventListener('click', () => {
          console.log('Pathfinding start button clicked');
          if (pathViz) pathViz.start();
        });
      } else {
        console.error('Pathfinding start button not found');
      }
      
      if (pathResetBtn) {
        console.log('Pathfinding reset button found');
        pathResetBtn.addEventListener('click', () => {
          console.log('Pathfinding reset button clicked');
          if (pathViz) pathViz.reset();
        });
      } else {
        console.error('Pathfinding reset button not found');
      }
      
      const neuralTrainBtn = document.getElementById('neuralTrain');
      const neuralResetBtn = document.getElementById('neuralReset');
      
      if (neuralTrainBtn) {
        console.log('Neural train button found');
        neuralTrainBtn.addEventListener('click', () => {
          console.log('Neural train button clicked');
          if (neuralViz && neuralViz.train) neuralViz.train();
        });
      } else {
        console.error('Neural train button not found');
      }
      
      if (neuralResetBtn) {
        console.log('Neural reset button found');
        neuralResetBtn.addEventListener('click', () => {
          console.log('Neural reset button clicked');
          if (neuralViz) {
            neuralViz.isTraining = false;
            neuralViz.lossHistory = [];
            if (neuralViz.drawNetwork) neuralViz.drawNetwork();
            if (neuralViz.drawLoss) neuralViz.drawLoss();
          }
        });
      } else {
        console.error('Neural reset button not found');
      }
      
      // Initial draws with error handling
      if (neuralViz) {
        setTimeout(() => {
          try {
            if (neuralViz.drawNetwork) {
              neuralViz.drawNetwork();
              console.log('Neural network initial visualization drawn');
            }
            if (neuralViz.drawLoss) {
              neuralViz.drawLoss();
            }
          } catch (error) {
            console.error('Error drawing initial neural network:', error);
          }
        }, 100);
      }
      
      console.log('✅ Algorithm Visualizer initialization complete!');
    });
  </script>
</body>
</html>